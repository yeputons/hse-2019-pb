% !TeX root = 191107.tex
\begin{frame}[t]{Функции высшего порядка: резюме}
	\begin{itemize}
	\item
		\textit{Функция высшего порядка} "--- функция,
		которая в качестве одного из аргументов ожидает функцию.
	\item
		Элемент функционального программирования
	\item
		Ещё один способ композиции кода
	\item
		В разных языках удобен в разной степени (на Си неудобно)
	\item
		\textit{Лямбда-функция} "--- функция без имени
	\end{itemize}
\end{frame}

\begin{frame}[t]{Декораторы: резюме}
	Синтаксический сахар Python для добавления свойств и кода к функциям:
	\begin{itemize}
	\item Запомнить результат вызова и не пересчитывать
	\item Вывести на экран количество вызовов, время работы
	\item Перед запуском функции проверить права пользователя
	\item
		Автоматически переписать числа Фибоначчи на возведение
		матрицы в степень: \href{https://habr.com/ru/post/236689/}{habr.com/ru/post/236689}
	\end{itemize}
	
	Стал возможным, так как функции "--- \textit{объект первого класса},
	с ними можно работать, как с данными.
\end{frame}

\begin{frame}[t,fragile]{Замыкания и область видимости: резюме}
	Область видимости определяется \textit{лексически} (lexical scoping)
	\begin{itemize}
	\item Область видимости "--- либо глобальная, либо какая-то функция
	\item Каждая переменная либо <<объявлена>> в области видимости, либо нет
		(есть оператор вроде \verb`=` или \verb`+=` или нет)
	\item Это определяется во время компиляции
	\item Каждое имя обращается к какой-то переменной в какой-то области видимости (правило LEGB\footnote{\href{https://www.python.org/dev/peps/pep-3104/}{PEP 3104}})
	\item Чтобы не объявлять новую переменную:
		\verb`global` и \verb`nonlocal`
	\item Что-то подобное "--- во всех современных языках
	\end{itemize}
	
	Ещё бывает динамическая область видимости (dynamical scoping):
	\begin{itemize}
	\item От структуры кода ничего не зависит, смотрим на стэк вызовов
	\item Примеры: Lisp, \LaTeX, Perl, bash
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Исключения}
	\begin{itemize}
	\item \textit{Один из} способов обработки ошибок в программах
	\item Для \textit{исключительных} ситуаций, когда не сразу ясно, что делать
	\item Идея: если нам неясно, что делать, попросим разобраться вызывающего:
		файл не найден $\Rightarrow$ сообщить пользователю
	\item Есть в половине современных языков программирования
	\item
		Обычно сильно медленнее возврата значения и не так красиво
	\end{itemize}
	
	Обработка ошибок "--- это сложно: надо очень хорошо понять,
	что делать при каких ошибках
	\footnote{<<Открытие файла>> иногда надо попробовать снова,
	иногда попробовать другой файл, иногда сообщить пользователю}.
	Разным задачам "--- разные инструменты.

	\begin{itemize}
	\item Передавать код ошибки в глобальной переменной: забывают
	\item Функция возвращает код ошибки:
		неудобно возвращать значение
	\item Функция возвращает либо код ошибки, либо значение.
		Дальше либо явно обработать (Go),
		либо есть сахар (Haskell, Rust)
	\item Перезапустить процесс (Erlang)
	\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Заключение}
	Классный курс по Python в Computer Science Center:
	\href{https://compscicenter.ru/courses/python/2015-autumn/classes/}{compscicenter.ru/courses/python/2015-autumn}
	
	В домашнем задании надо сделать утилиту с нуля,
	правильно разбить на процедуры, всё протестировать.
\end{frame}
